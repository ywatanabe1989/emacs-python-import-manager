;;; -*- lexical-binding: t -*-
;;; Author: ywatanabe
;;; Time-stamp: <2024-10-31 23:42:07>
;;; File: ./.dotfiles/.emacs.d/lisp/python-import-manager/python-import-manager.el

;;; python-import-manager.el --- Manage Python imports automatically -*- lexical-binding: t -*-

;; Copyright (C) 2024 ywatanabe

;; Author: Yusuke Watanabe (ywatanabe@alumni.u-tokyo.ac.jp)
;; Version: 1.0.0
;; Package-Requires: ((emacs "26.1"))
;; Keywords: languages, tools, python
;; URL: https://github.com/ywatanabe/python-import-manager

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; Python Import Manager (PIM) automatically manages Python imports in your code.
;; It can detect unused imports and add missing ones based on actual usage.

;;; Code:
(require 'async)
(require 'json)
(unless (fboundp 'json-read)
  (require 'json-mode))
(require 'seq)

;; Customization
(defgroup python-import-manager nil
  "Management of Python imports."
  :group 'tools
  :prefix "pim-")

(define-minor-mode pim-auto-mode
  "Minor mode to automatically fix imports on save."
  :lighter " PIM"
  (if pim-auto-mode
      (add-hook 'before-save-hook #'pim-fix-imports nil t)
    (remove-hook 'before-save-hook #'pim-fix-imports t)))

(defcustom pim-python-interpreter "python"
  "Python interpreter to use for import checking."
  :type 'string
  :group 'python-import-manager)

;; Variables
(defcustom pim-import-aliases
  '(("numpy" . "np")
    ("pandas" . "pd")
    ("matplotlib.pyplot" . "plt")
    ("seaborn" . "sns"))
  "Alist of package names and their preferred aliases."
  :type '(alist :key-type string :value-type string)
  :group 'python-import-manager)

(defvar pim-available-packages nil
  "Cache of available Python packages.")

(defvar pim--module-contents-cache (make-hash-table :test 'equal)
  "Cache of module contents to avoid repeated Python calls.")

(defvar pim--cache-file
  (expand-file-name "pim-cache.el" user-emacs-directory)
  "File to cache package information.")

(cl-defun --pim-get-module-contents-cached (module)
  "Get cached contents for MODULE, or fetch and cache if not present."
  (or (gethash module pim--module-contents-cache)
      (puthash module (--pim-get-module-contents module) 
               pim--module-contents-cache)))

(cl-defun --pim-is-python-buffer-p ()
  "Check if current buffer is a Python file."
  (or (derived-mode-p 'python-mode)
      (string-match "\\.py$" (buffer-file-name))
      (save-excursion
        (goto-char (point-min))
        (looking-at-p "#!.*python"))))

;; Internal Functions
(cl-defun --pim-check-import (package)
  "Check if PACKAGE can be imported in current Python environment."
  (= 0 (call-process pim-python-interpreter nil nil nil
                     "-c" (format "import %s" package))))

(cl-defun --pim-get-buffer-imports ()
  "Get all imports in current buffer."
  (let ((imports '()))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\\(import\\|from\\) \\([[:alnum:]_.]+\\)" nil t)
        (push (match-string 2) imports)))
    imports))

(defun pim--run-python-code (code)
  "Run Python CODE and return its output."
  (with-temp-buffer
    (call-process pim-python-interpreter nil t nil "-c" code)
    (buffer-string)))

(defun pim-inspect-module (module)
  "Display detailed inspection of Python MODULE."
  (interactive "sModule name: ")
  (let ((buf (get-buffer-create "*Python Module Inspection*")))
    (with-current-buffer buf
      (erase-buffer)
      (insert (pim--run-python-code 
               (format "
import inspect, sys, pandas as pd
from typing import Optional, Set, List, Tuple

%s

module = __import__('%s')
df = inspect_module(module)
print(df.to_string())" 
                       (with-temp-buffer
                         (insert-file-contents 
                          (expand-file-name "inspect_module.py" 
                                          (file-name-directory load-file-name)))
                         (buffer-string))
                       module)))
      (display-buffer buf))))

(cl-defun --pim-get-module-contents (module)
  "Get submodules and functions from MODULE."
  (with-temp-buffer
    (call-process pim-python-interpreter nil t nil
                  "-c" (format "
import inspect
import %s

for name, obj in inspect.getmembers(%s):
    if name.startswith('_'):
        continue
    if inspect.ismodule(obj):
        print(f'{name}:module')
    elif inspect.isfunction(obj):
        print(f'{name}:function')
    elif inspect.isclass(obj):
        print(f'{name}:class')
" module module))
    (split-string (buffer-string) "\n" t)))


(defun --pim-get-buffer-uses ()
  "Get list of packages used in current buffer."
  (let ((package-names '()))
    (save-excursion
      (goto-char (point-min))
      ;; Only scan non-comment, non-string content
      (while (re-search-forward "\\_<\\([[:alnum:]_]+\\)\\." nil t)
        (unless (or (nth 3 (syntax-ppss)) ; in string
                   (nth 4 (syntax-ppss))) ; in comment
          (push (match-string 1) package-names))))
    (delete-dups package-names)))

(defun --pim-package-exists-p (package)
  "Check if PACKAGE exists in available packages."
  (and package
       (assoc package pim-available-packages)))

(cl-defun --pim-get-installed-packages ()
  "Get list of installed Python packages using pip list."
  (with-temp-buffer
    (call-process pim-python-interpreter nil t nil
                  "-m" "pip" "list" "--format=json")
    (goto-char (point-min))
    (let* ((json-array-type 'list)
           (packages (json-read)))
      (mapcar (lambda (pkg) (cdr (assoc 'name pkg))) packages))))

(cl-defun --pim-get-stdlib-modules ()
  "Get list of Python standard library modules."
  (with-temp-buffer
    (call-process pim-python-interpreter nil t nil
                  "-c" "import sys, pkgutil; print('\\n'.join(m[1] for m in pkgutil.iter_modules(sys.stdlib_module_names)))")
    (split-string (buffer-string) "\n" t)))

;; (cl-defun --pim-package-exists-p (package)
;;   "Check if PACKAGE exists in the cached package list."
;;   (unless pim-available-packages
;;     (pim-update-package-index))
;;   (member package pim-available-packages))

(cl-defun --pim-get-buffer-uses ()
  "Get all symbol uses in current buffer."
  (let ((uses '()))
    (save-excursion 
      (goto-char (point-min))
      ;; Match module uses: numpy.array, os.path
      (while (re-search-forward "\\([[:alnum:]_]+\\)\\." nil t)
        (push (match-string 1) uses))
      ;; Match direct function uses: array(...), path.join(...)
      (goto-char (point-min))
      (while (re-search-forward "\\([[:alnum:]_]+\\)(" nil t)
        (push (match-string 1) uses)))
    (delete-dups uses)))

(cl-defun --pim-get-module-contents (module)
  "Get submodules and functions from MODULE."
  (with-temp-buffer
    (call-process pim-python-interpreter nil t nil
                  "-c" (format "
import %s
import inspect
for name, obj in inspect.getmembers(%s):
    if not name.startswith('_'):
        print(f'{name}:{type(obj).__name__}')
" module module))
    (split-string (buffer-string) "\n" t)))


(cl-defun --pim-get-buffer-uses ()
  "Get all symbol uses in current buffer."
  (let ((uses '()))
    (save-excursion 
      (goto-char (point-min))
      ;; Match various Python usage patterns
      (while (re-search-forward (rx (or
                                   ;; Module usage: numpy.array
                                   (group (1+ (or alnum "_"))) "."
                                   ;; Function calls: array(...)
                                   (group (1+ (or alnum "_"))) "("
                                   ;; Class usage: DataFrame([...])
                                   (group (1+ (or alnum "_"))) "["
                                   ;; Import aliases: import numpy as np
                                   "import" (1+ space) (group (1+ (or alnum "_"))) (opt (1+ space) "as")
                                   ;; From imports: from numpy import array
                                   "from" (1+ space) (group (1+ (or alnum "_"))))) nil t)
        (when-let ((match (or (match-string 1) (match-string 2) 
                             (match-string 3) (match-string 4) 
                             (match-string 5))))
          (push match uses))))
    (delete-dups uses)))

;; Interactive Commands
;; ;;;###autoload
;; (defun pim-fix-imports ()
;;   "Fix imports in current buffer."
;;   (interactive)
;;   (unless (--pim-is-python-buffer-p)
;;     (user-error "Not a Python buffer"))
  
;;   (if (not pim-available-packages)
;;       (progn
;;         (message "Package index not initialized. Please run M-x pim-update-package-index and try again later. This may take a few seconds.")
;;         nil)
    
;;     (let* ((imports (--pim-get-buffer-imports))
;;            (uses (--pim-get-buffer-uses))
;;            (unused (seq-difference imports uses))
;;            (missing (seq-filter #'--pim-package-exists-p
;;                               (seq-difference uses imports))))
;;       (save-excursion
;;         (dolist (unused-import unused)
;;           (goto-char (point-min))
;;           (when (re-search-forward (format "^.*%s.*$" unused-import) nil t)
;;             (kill-whole-line))))
;;       (save-excursion
;;         (goto-char (point-min))
;;         (dolist (missing-import missing)
;;           (if-let ((alias (cdr (assoc missing pim-import-aliases))))
;;               (insert (format "import %s as %s\n" missing alias))
;;             (insert (format "import %s\n" missing-import)))))
;;       (message "Removed: %s, Added: %s" unused missing))))

(defcustom pim-pyflakes-path
  (executable-find "pyflakes")
  "Path to pyflakes executable."
  :type 'string
  :group 'python-import-manager)

(defun pim--parse-pyflakes-output (output)
  "Parse pyflakes OUTPUT to get unused imports."
  (let* ((raw-lines (split-string (string-trim output) "\n"))
         (lines (mapcar (lambda (line) 
                         (split-string line ":" t " +"))
                       raw-lines)))
    (seq-filter (lambda (parts)
                  (and (>= (length parts) 3)
                       (string-match-p "imported but unused" (nth 2 parts))))
                lines)))

(defcustom pim-flake8-path
  (executable-find "flake8")
  "Path to flake8 executable."
  :type 'string
  :group 'python-import-manager)

(defcustom pim-flake8-args
  '("--max-line-length=100" "--select=F401,F821" "--isolated")
  "Arguments to pass to flake8."
  :type '(repeat string)
  :group 'python-import-manager)

(defun pim-find-flake8 ()
  "Find flake8 executable."
  (interactive)
  (let* ((default-directory (file-remote-p default-directory))
         (path (or pim-flake8-path
                  (executable-find "flake8")
                  (user-error "Cannot find flake8. Please install it or set pim-flake8-path"))))
    (when (called-interactively-p 'any)
      (message "Found flake8 at: %s" path))
    path))

(defun pim-copy-contents-as-temp-file ()
  "Copy current buffer to temp file and return the filename."
  (let ((temp-file (make-temp-file "flake8-")))
    (print (format "Created temp file: %s" temp-file))
    (write-region (point-min) (point-max) temp-file)
    temp-file))

(defun pim-get-flake8-output (temp-file &optional args)
  "Run flake8 on TEMP-FILE with optional ARGS and return output."
  (let ((flake8-path (pim-find-flake8))
        output)
    (print (format "Using flake8 at: %s" flake8-path))
    (print (or args pim-flake8-args))
    (with-temp-buffer
      (apply #'call-process flake8-path nil t nil 
             (append (or args pim-flake8-args) (list temp-file)))
      (setq output (buffer-string)))
    (print output)
    output))

(defun pim-find-undefined ()
  "Find undefined names from flake8 output."
  (interactive)
  (print "pim-find-undefined called")
  (when (= (point-min) (point-max))
    (user-error "Buffer is empty"))
  (let* ((temp-file (pim-copy-contents-as-temp-file))
         (undefined-list '())
         (output (pim-get-flake8-output temp-file '("--select=F821"))))
    (with-temp-buffer
      (insert output)
      (goto-char (point-min))
      (while (re-search-forward "F821 undefined name '\\([^']+\\)'" nil t)
        (push (match-string 1) undefined-list)))
    (delete-file temp-file)
    (print undefined-list)
    undefined-list))

;; (defun pim-find-undefined ()
;;   "Find undefined names from flake8 output."
;;   (interactive)
;;   (when (= (point-min) (point-max))
;;     (user-error "Buffer is empty"))
;;   (let ((undefined-list '())
;;         (temp-file (pim-copy-contents-as-temp-file))
;;         (output (pim-get-flake8-output temp-file)))
;;     (with-temp-buffer
;;       (insert output)
;;       (goto-char (point-min))
;;       (while (re-search-forward "F821 undefined name '\\([^']+\\)'" nil t)
;;         (push (match-string 1) undefined-list)))
;;     (delete-file temp-file)
;;     undefined-list))

(defun pim--parse-flake8-output (output)
  "Parse flake8 output to get unused imports."
  (interactive)
  (let (imports)
    (dolist (line (split-string output "\n" t))
      (when (string-match ":\\([0-9]+\\):[0-9]+: F401 '\\([^']+\\)' imported but unused" line)
        (push (list (match-string 1 line)   ; line number
                   "F401"                   ; error code
                   (match-string 2 line))   ; import name
              imports)))
    (nreverse imports)))

(defun pim-find-unused-modules ()
  "Find unused modules from flake8 output."
  (let* ((unused-imports (pim-find-unused))
         (modules (mapcar (lambda (import)
                          (car (last (split-string (nth 2 import) "\\."))))
                        unused-imports)))
    modules))

(defun pim-remove-module (module)
  "Remove specific module from import lines."
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "^from .* import.*$" nil t)
      (let* ((line (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
             (imports (when (string-match "import \\(.+\\)" line)
                       (split-string (match-string 1 line) "," t "[\s\t]+")))
             (new-imports (remove module imports)))
        (when (and imports (not (equal imports new-imports)))
          (delete-region (line-beginning-position) (line-end-position))
          (if new-imports
              (insert (format "from %s import %s" 
                            (progn (string-match "from \\([^ ]+\\) import" line)
                                   (match-string 1 line))
                            (string-join new-imports ", ")))
            (kill-whole-line)))))))

(defun pim-cleanup-imports ()
  "Remove empty import lines."
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "^from .* import *$" nil t)
      (kill-whole-line))))

;;;; WORKING!!!
;;;autoload
(defun pim-delete-unused ()
  "Main function to handle unused imports."
  (interactive)
  (let ((unused-modules (pim-find-unused-modules)))
    (dolist (module unused-modules)
      (pim-remove-module module))
    (pim-cleanup-imports)))


(defun pim--parse-undefined-names (output)
  "Parse pyflakes OUTPUT to get undefined names."
  (let* ((raw-lines (split-string (string-trim output) "\n"))
         (lines (mapcar (lambda (line) 
                         (split-string line ":" t " +"))
                       raw-lines)))
    (seq-filter (lambda (parts)
                  (and (>= (length parts) 3)
                       (string-match-p "undefined name" (nth 2 parts))))
                lines)))

(defun pim-find-undefined ()
  "Find undefined names from flake8 output."
  (interactive)
  (let ((undefined-list '()))
    (save-excursion
      (with-temp-buffer
        (call-process "flake8" nil t nil (buffer-file-name))
        (goto-char (point-min))
        (while (re-search-forward "F821 undefined name '\\([^']+\\)'" nil t)
          (push (match-string 1) undefined-list))))
    undefined-list))

;;;###autoload  
(defun pim-insert-missing ()
  "Insert missing imports using flake8 undefined name errors."
  (interactive)
  (let ((undefined-names (pim-find-undefined)))
    (unless undefined-names
      (user-error "No undefined names found"))
    (save-excursion
      (goto-char (point-min))
      (when (re-search-forward "^import\\|^from" nil t)
        (beginning-of-line)
        (dolist (name undefined-names)
          (insert (format "from %s import %s\n" 
                         (downcase name) name)))))))

;;;###autoload  
(defun pim-delete-duplicates ()
  "Remove duplicate import statements."
  (interactive)
  (save-excursion
    (let ((imports (make-hash-table :test 'equal)))
      ;; Collect imports
      (goto-char (point-min))
      (while (re-search-forward "^\\(from .* import .*\\|import .*\\)$" nil t)
        (let ((line (match-string 0)))
          (if (gethash line imports)
              ;; If duplicate found, delete the line
              (kill-whole-line)
            ;; Store first occurrence
            (puthash line t imports))))
      (message "Removed duplicate imports"))))

;;;###autoload  
(defun pim-fix-imports ()
  "Fix imports in current buffer."
  (interactive)
  (pim-delete-unused)
  (pim-insert-missing)
  (pim-delete-duplicates))

;;;###autoload
(defun pim-set-interpreter ()
  "Set Python interpreter for import checking."
  (interactive)
  (let ((interpreter (read-string "Python interpreter: " pim-python-interpreter)))
    (setq pim-python-interpreter interpreter)))

(defun pim-update-package-index ()
  "Update package index with caching."
  (interactive)
  (if (file-exists-p pim--cache-file)
      (setq pim-available-packages 
            (with-temp-buffer
              (insert-file-contents pim--cache-file)
              (read (current-buffer))))
    (setq pim-available-packages (--pim-get-installed-packages))
    (with-temp-file pim--cache-file
      (print pim-available-packages (current-buffer)))))

(cl-defun pim-sort-imports ()
  "Sort Python imports according to PEP 8."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((imports-region (progn
                           (while (and (not (eobp))
                                     (or (looking-at "^\\s-*$")
                                         (looking-at "^#")
                                         (looking-at "^\\(import\\|from\\)")))
                             (forward-line))
                           (point-marker))))
      (sort-lines nil (point-min) imports-region))))

(defcustom pim-virtualenv-path nil
  "Path to Python virtual environment to use."
  :type '(choice (const :tag "None" nil)
                (string :tag "Path"))
  :group 'python-import-manager)

(cl-defun pim-set-virtualenv ()
  "Set virtual environment for import checking."
  (interactive)
  (let ((venv-path (read-directory-name "Virtual environment path: ")))
    (setq pim-virtualenv-path venv-path
          pim-python-interpreter (expand-file-name "bin/python" venv-path))))


(provide 'python-import-manager)

;;; python-import-manager.el ends here

(message "%s was loaded." (file-name-nondirectory (or load-file-name buffer-file-name)))
